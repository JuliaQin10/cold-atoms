#include "nr3.h"
#include "gamma.h"
#include <armadillo>
#include <fstream>
#include <list>
using namespace arma;
//In preface, Numerical explains that they deliberately exclude #include statements
//Found include statements at nr.com/dependencies
//Retrieved files from website
double pi=4.*atan(1);

void gauleg(const Doub x1, const Doub x2, VecDoub_O &x, VecDoub_O &w) //x and w are customized variables defined in previous files
//Doub not a fundamental type, it's a function defined in nr3.h and gamma.h
//Vec not a standard library container, it's a function defined in nr3.h and gamma.h
{
    const Doub EPS=1.0e-14; //EPS is the relative precision.
    Doub z1,z,xm,xl,pp,p3,p2,p1;
    Int n=x.size(); //sets n to the number of elemetns in x
    Int m=(n+1)/2; //The roots are symmetric in the interval, so
    xm=0.5*(x2+x1); //we only have to find half of them.
    xl=0.5*(x2-x1);
    for (Int i=0;i<m;i++) { //Loop over the desired roots.
        z=cos(3.141592654*(i+0.75)/(n+0.5)); //Starting with this approximation to the ith root, we enter the main loop of refinement by Newton’s method.
        do {
            p1=1.0;
            p2=0.0;
            for (Int j=0;j<n;j++) { //Loop up the recurrence relation to get the
                p3=p2; //Legendre polynomial evaluated at z.
                p2=p1;
                p1=((2.0*j+1.0)*z*p2-j*p3)/(j+1);
            }
            //p1 is now the desired Legendre polynomial. We next compute pp, its derivative, by a standard relation involving also p2, the polynomial of one lower order.
            pp=n*(z*p1-p2)/(z*z-1.0);
            z1=z;
            z=z1-p1/pp; //Newton’s method.
        } while (abs(z-z1) > EPS);
        x[i]=xm-xl*z; //Scale the root to the desired interval,
        x[n-1-i]=xm+xl*z; //and put in its symmetric counterpart.
        w[i]=2.0*xl/((1.0-z*z)*pp*pp); //Compute the weight
        w[n-1-i]=w[i]; //and its symmetric counterpart.
    }
}
Doub dimer(Doub g, Doub p, Doub E, Doub m)
{
    return (2./pi)*pow(p,2)/(sqrt(.75*pow(p,2)-m*E)-g);
}


Doub exchange(Doub q, Doub p, Doub E, Doub m)
{
    return (1./(q*p))*log((pow(q,2)+pow(p,2)+q*p-m*E)/(pow(q,2)+pow(p,2)-q*p-m*E));
}

Doub inhomogenous(Doub ro, Doub g, Doub p, Doub m, Doub E)
{
    return (ro/2)*(g+sqrt(.75*pow(p,2)-m*E));
}

Doub dimer2(Doub g, Doub q, Doub E, Doub m)
{
    return (2./pi)*pow(q,2)/(sqrt(.75*pow(q,2)-m*E)-g);
}

Doub exchangeprime(Doub q, Doub p, Doub E, Doub m)
{
    return (2*m)/(pow(pow(q,2)+pow(p,2)-m*E,2)-pow(q,2)*pow(p,2));
}

Doub dimer2prime(Doub g, Doub q, Doub E, Doub m)
{
    return (m/pi)*pow(q,2)/(sqrt(.75*pow(q,2)-m*E)*pow(sqrt(.75*pow(q,2)-m*E)-g,2));
}

Doub timesgamma0(Doub g, Doub q, Doub E, Doub m)
{
    return (m/(4.*pi))*pow(q,2)/(pow((sqrt(.75*pow(q,2)-m*E)-g),2)*sqrt(.75*pow(q,2)-m*E));
}

Doub timesgamma0prime(Doub g, Doub q, Doub E, Doub m)
{
    return (1./(2.*pi))*pow(q,2)/(sqrt(.75*pow(q,2)-m*E)-g);
}

Doub check1(Doub g, Doub l, Doub E, Doub m)
{
    return pow(l,2)*m/(4.*pi*pow(g-sqrt(.75*pow(l,2)-m*E),2)*sqrt(.75*pow(l,2)-m*E));
    //return pow(l,2)*m/(4.*pi*sqrt(.75*pow(l,2)-m*E));
}
Doub check2(Doub g, Doub l, Doub q, Doub E, Doub m)
{
    return 2.*pow(l,2)*pow(q,2)*m/(pi*pi*(g-sqrt(.75*pow(q,2)-m*E))*(g-sqrt(.75*pow(l,2)-m*E))*(pow(q,2)*pow(l,2)-pow((pow(q,2)+pow(l,2)-m*E),2)));
    //return 2.*pow(l,2)*pow(q,2)*m/(pi*pi*(pow(q,2)*pow(l,2)-pow((pow(q,2)+pow(l,2)-m*E),2)));
}

Doub Dtilde(Doub q, Doub m, Doub E)
{
    return sqrt(.75*pow(q,2)-m*E);
}

Doub Dts(Doub g, Doub q, Doub E, Doub m)
{
    return g-Dtilde(q, m, E);
}

Doub B2(Doub g, Doub q, Doub E, Doub m)
{
    return m/(384*pi*pi*pow(Dtilde(q, m, E), 5)*pow(Dts(g, q, E, m), 4))*(q*q*(pow(Dts(g, q, E, m),2)-2*Dts(g, q, E, m)*Dtilde(q, m, E)+2*pow(Dtilde(q, m, E),2))+4*Dts(g, q, E, m)*pow(Dtilde(q, m, E),2)*(3*Dtilde(q, m, E)-g));
}

Doub variablea(Doub q, Doub p, Doub m, Doub E)
{
    return (pow(q,2)+pow(p,2)-m*E)/(q*p);
}

Doub Q0(Doub q, Doub p, Doub m, Doub E)
{
    return 0.5*log((1+variablea(q, p, m, E))/(variablea(q, p, m, E)-1));
}

Doub B7(Doub g, Doub q, Doub E, Doub m, Doub p)
{
    return -2*pi*B2(g, q, E, m)*Q0(q, p, m, E)/(p*q)-m/(27*pi*Dts(g, q, E, m)*pow(p*q,3))*((5*variablea(q, p, m, E)/pow(1-pow(variablea(q, p, m, E),2),2))+((q/p+p/q)*(1+3*pow(variablea(q, p, m, E),2))-variablea(q, p, m, E)*(3+pow(variablea(q, p, m, E),2)))/(pow(1-pow(variablea(q, p, m, E),2),3)))-m/(432*pi*pow(Dtilde(q, m, E)*Dts(g, q, E, m),3)*pow(p*q,2))*(Dtilde(q, m, E)*Dtilde(q, m, E)*Dts(g, q, E, m)*(38/(1-pow(variablea(q, p, m, E),2))+((20*q/p+8*p/q)*variablea(q, p, m, E)-4*(1+pow(variablea(q, p, m, E),2)))/pow(1-pow(variablea(q, p, m, E),2),2))-(g-3*Dtilde(q, m, E))*(9*pow(q,2)/(2*(1-pow(variablea(q, p, m, E),2)))));
}

Doub variableb(Doub q, Doub k, Doub m, Doub E)
{
    return (pow(q,2)+pow(k,2)-m*E)/(q*k);
}

Doub Q0b(Doub q, Doub k, Doub m, Doub E)
{
    return 0.5*log((1+variableb(q, k, m, E))/(variableb(q, k, m, E)-1));
}

Doub B12(Doub g, Doub q, Doub E, Doub m, Doub p, Doub k)
{
    Doub a=variablea(q, p, m, E);
    Doub b=variableb(q, k, m, E);
    Doub D=Dts(g,q,E,m);
    Doub Dtitle=Dtilde(q, m, E);
    return -2*pi*(B7(g, q, E, m, k)*Q0(q, p, m, E)/(p*q)+B7(g, q, E, m, p)*Q0b(q, k, m, E)/(k*q))-4*pi*pi*B2(g, q, E, m)*Q0b(q, k, m, E)*Q0(q, p, m, E)/(k*q*p*q)+m/(54*Dtitle*pow(D*p*k*q*q,2))*(2*Dtitle*D*((12*(1-b*b)*(1-a*a)+4*q*a/p*(1-b*b)+4*q*b/k*(1-a*a))+2*a*b*(k/p*(1-b*b)+p/k*(1-a*a))+2*b*k/q*(2*b*b-(1+a*a))+2*a*p/q*(2*a*a-(1+b*b))+2*k/q*(q*a/p-2)*pow(1-b*b,2)*Q0b(q, k, m, E)+2*p/q*(q*b/k-2)*pow(1-a*a,2)*Q0(q, p, m, E))/(pow(1-b*b,2)*pow(1-a*a,2))+q*q*((4+k*b/q+p*a/q-2*k*p*a*b/(q*q))+k/q*(1-b*b)*(1-2*a*p/q)*Q0b(q, k, m, E)+p/q*(1-a*a)*(1-2*b*k/q)*Q0(q, p, m, E)-2*k*p*(1-b*b)*(1-a*a)*Q0b(q, k, m, E)*Q0(q, p, m, E)/(q*q))/((1-b*b)*(1-a*a)));
}

Doub variablea2(Doub k, Doub p, Doub m, Doub E)
{
    return (pow(p,2)+pow(k,2)-m*E)/(p*k);
}

Doub B19(Doub g, Doub E, Doub m, Doub k)
{
    return m/(384*pow(Dtilde(k, m, E),5)*pow(Dts(g, k, E, m),3))*
    (4*pow(Dtilde(k, m, E),2)*Dts(g, k, E, m)*(2*Dtilde(k, m, E)-g)+pow(k,2)*(g-3*Dtilde(k, m, E))*Dts(g, k, E, m)+2*pow(k,2)*pow(Dtilde(k, m, E),2));
}

Doub Q0a2(Doub k, Doub p, Doub m, Doub E)
{
    return 0.5*log((1+variablea2(k, p, m, E))/(variablea2(k, p, m, E)-1));
}

Doub B24(Doub g, Doub E, Doub m, Doub p, Doub k)
{
    Doub B_19=B19(g,E,m,k);
    Doub Q0a=Q0a2(k, p, m, E);
    Doub tilde=Dtilde(k, m, E);
    Doub D=Dts(g, k, E, m);
    Doub a=variablea2(k, p, m, E);
    Doub a2=a*a;
    return -2*pi*B_19*Q0a/(p*k)
    -m*pi/(54*tilde*D*p*k)*(1/(p*k*(1-a2))+(1/(pow(p,2))*(4*a+a*pow(p/k,2)-2*p/k*(1+a2))/(pow(1-a2,2))))
    -m*pi*k/(144*p*pow(tilde,3)*pow(D,2))*(Q0a/(k*k)-(2-p*a/k)/(p*k*(1-a2)))*(g-3*tilde);
}

Doub B16(Doub k, Doub p, Doub m, Doub E)
{
    return -2*m*pi/(9*pow(p,3)*pow(k,3)*pow(1-pow(variablea2(k, p, m, E),2),2))*((4*variablea2(k, p, m, E)/(3*(1-pow(variablea2(k, p, m, E),2))))-2*variablea2(k, p, m, E)-(pow(p,2)+pow(k,2))*(1+3*pow(variablea2(k, p, m, E),2))/(3*p*k*(1-pow(variablea2(k, p, m, E),2))))*-2/3;
}

Doub dimerp(Doub g, Doub p, Doub m, Doub E)
{
    return pow(p,2)/(2*pi*pi*(g-sqrt(.75*pow(p,2)-m*E)));
}

Doub dimerk(Doub g, Doub k, Doub m, Doub E)
{
    return pow(k,2)/(2*pi*pi*(g-sqrt(.75*pow(k,2)-m*E)));
}

Doub partofA(Doub q)
{
    return pow(q,2)*2/3;
}

int main()
{
    Doub g=0.;
    Doub m=938.;
    Doub q,p,l,k;
    Doub E=-8.;
    Doub ro=.01;
    Doub product, sigma0prime, check1sum, check2sum, diagrambsum, diagramb,diagrama,diagrama1sum,diagrama2sum,diagrama3sum,diagramc1sum,diagramc2sum,diagramc,checkdiagram, sigma0;
    int N=100;
    mat A(N,N);
    mat B;
    vec gamma1(N);
    vec productprime(N);
    int cutoff=100;
    VecDoub_O x(N);
    VecDoub_O w(N);
    ofstream plot0;
    ofstream plot1;
    ofstream plot0prime;
    ofstream plotsigma;
    for (int i=1;i<31;i++)
    {
        sigma0=0;
        sigma0prime=0;
        check1sum=0;
        check2sum=0;
        diagrambsum=0;
        diagrama1sum=0;
        diagrama2sum=0;
        diagrama3sum=0;
        diagramc1sum=0;
        diagramc2sum=0;
        cutoff=cutoff+100;
        plot0.open ("gamma0_"+to_string(cutoff)+".dat");
        plot1.open ("gamma1_"+to_string(cutoff)+".dat");
        plot0prime.open ("gamma0prime_"+to_string(cutoff)+".dat");
        plotsigma.open ("sigma0prime_"+to_string(cutoff)+".dat");
        gauleg(0.,cutoff,x,w);
        for(int i=1;i<x.size();i++)
        {
            q=x[i];
            for (int j=1;j<N;j++)
            {
                p=x[j];
                product=w[j]*dimer(g,p,E,m)*exchange(q,p,E,m);
                A(i,j)=product;
            }
        }
        mat identity (N, N,fill::eye);
        mat LO=identity-A;
        mat LO1=inv(LO);
        B.ones(1, N);
        vec gamma0=LO1*trans(B);
        for (int j=1;j<N;j++)
            gamma1(j)=gamma0(j)*inhomogenous(ro,g,x[j],m,E);
        gamma1=LO1*gamma1;
        for (int i=1;i<N;i++)
        {
            plot0<<x[i]<<"\t"<<gamma0(i)<<"\n";
            plot1<<x[i]<<"\t"<<gamma1(i)<<"\n";
        }
        for(int i=1;i<x.size();i++)
        {
            p=x[i];
            productprime(i)=0.0;
            for (int j=1;j<N;j++)
            {
                q=x[j];
                productprime(i)=productprime(i)+w[j]*dimer2(g, q, E, m)*gamma0(j)*exchangeprime(q, p, E, m)+w[j]*exchange(q,p,E,m)*gamma0(j)*dimer2prime(g, q, E, m);
            }
        }
        vec gamma0prime=LO1*productprime;
        for (int i=1;i<x.size();i++)
        {
            q=x[i];
            sigma0=sigma0+x[i]*dimer2(g, q, E, m)*gamma0(i);
        }
        
        for(int i=1;i<x.size();i++)
        {
            q=x[i];
            sigma0prime=sigma0prime+w[i]*timesgamma0(g, q, E, m)*gamma0(i)+w[i]*timesgamma0prime(g, q, E, m)*gamma0prime(i);
        }
        vec normalized=(sqrt(pi/sigma0prime))*gamma0;
        for (int i=1;i<N;i++)
        {
            plot0prime<<x[i]<<"\t"<<gamma0prime(i)<<"\n";
            plotsigma<<x[i]<<"\t"<<normalized(i)<<"\n";
        }
        for (int i=1;i<N;i++)
        {
            l=x[i];
            check1sum=check1sum+(w[i]*check1(g, l, E, m)*gamma0(i)*gamma0(i)/sigma0prime);
        }
        for (int i=1;i<N;i++)
        {
            l=x[i];
            for (int j=1;j<N;j++)
            {
                q=x[j];
                check2sum=check2sum+w[j]*w[i]*check2(g, l, q, E, m)*gamma0(j)*gamma0(i)/sigma0prime;
            }
        }
        cout<<"cutoff"<<'\t'<<cutoff<<endl;
        cout<<"normalization"<<'\t'<<(check1sum)<<'\t'<<check2sum<<'\t'<<check1sum-check2sum<<endl;
        plot0.close();
        plot1.close();
        plot0prime.close();
        plotsigma.close();
        for (int i=1;i<N;i++)
        {
            p=x[i];
            for (int j=1;j<N;j++)
            {
                k=x[j];
                diagrambsum=diagrambsum+w[i]*dimerp(g, p, m, E)*gamma0(i)*w[j]*B16(k, p, m, E)*dimerk(g, k, m, E)*gamma0(j);
            }
        }
        diagramb=diagrambsum*pi/sigma0prime;
        cout<<"diagramb"<<'\t'<<diagramb<<endl;
        for (int z=1;z<N;z++)
        {
            q=x[z];
            diagrama3sum=diagrama3sum+w[z]*partofA(q)*B2(g, q, E, m);
            for (int i=1;i<N;i++)
            {
                p=x[i];
                diagrama2sum=diagrama2sum+8*w[i]*dimerp(g, p, m, E)*gamma0(i)*w[z]*partofA(q)*B7(g, q, E, m, p);
                for (int j=1;j<N;j++)
                {
                    k=x[j];
                    diagrama1sum=diagrama1sum+16*dimerp(g, p, m, E)*gamma0(i)*w[i]*w[j]*dimerk(g, k, m, E)*gamma0(j)*w[z]*partofA(q)*B12(g, q, E, m, p, k);
                }
            }
        }
        
        for (int i=1;i<N;i++)
        {
            k=x[i];
            diagramc1sum=diagramc1sum+w[i]*dimerk(g, k, m, E)*gamma0(i)*2*B19(g,E,m,k)*3;
            for (int j=1;j<N;j++)
            {
                p=x[j];
                diagramc2sum=diagramc2sum+w[j]*dimerp(g, p, m, E)*gamma0(j)*w[i]*dimerk(g, k, m, E)*gamma0(i)*2*B24(g, E, m, p, k);
            }
        }
        diagrama=(diagrama1sum+diagrama2sum+diagrama3sum)*pi/sigma0prime;
        cout<<"diagrama"<<'\t'<<diagrama<<endl;
        diagramc=(diagramc1sum*(4./9.)+diagramc2sum*(16./3.))*pi/sigma0prime;
        cout<<"diagramc"<<'\t'<<diagramc<<endl;
        checkdiagram=diagrama+diagramb+diagramc;
        cout<<"checkdiagram"<<'\t'<<checkdiagram<<endl;
        cout<<-6.*(diagrama+4.*diagramb+diagramc)*m*E*.5<<endl;
    }
}

