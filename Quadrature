#include "nr3.h"
#include "gamma.h"
#include <armadillo>
#include <fstream>
#include <list>
using namespace arma;
//In preface, Numerical explains that they deliberately exclude #include statements
//Found include statements at nr.com/dependencies
//Retrieved files from website
double pi=4.*atan(1);

void gauleg(const Doub x1, const Doub x2, VecDoub_O &x, VecDoub_O &w) //x and w are customized variables defined in previous files
//Doub not a fundamental type, it's a function defined in nr3.h and gamma.h
//Vec not a standard library container, it's a function defined in nr3.h and gamma.h
{
    const Doub EPS=1.0e-14; //EPS is the relative precision.
    Doub z1,z,xm,xl,pp,p3,p2,p1;
    Int n=x.size(); //sets n to the number of elemetns in x
    Int m=(n+1)/2; //The roots are symmetric in the interval, so
    xm=0.5*(x2+x1); //we only have to find half of them.
    xl=0.5*(x2-x1);
    for (Int i=0;i<m;i++) { //Loop over the desired roots.
        z=cos(3.141592654*(i+0.75)/(n+0.5)); //Starting with this approximation to the ith root, we enter the main loop of refinement by Newton’s method.
        do {
            p1=1.0;
            p2=0.0;
            for (Int j=0;j<n;j++) { //Loop up the recurrence relation to get the
                p3=p2; //Legendre polynomial evaluated at z.
                p2=p1;
                p1=((2.0*j+1.0)*z*p2-j*p3)/(j+1);
            }
           //p1 is now the desired Legendre polynomial. We next compute pp, its derivative, by a standard relation involving also p2, the polynomial of one lower order.
            pp=n*(z*p1-p2)/(z*z-1.0);
            z1=z;
            z=z1-p1/pp; //Newton’s method.
        } while (abs(z-z1) > EPS);
        x[i]=xm-xl*z; //Scale the root to the desired interval,
        x[n-1-i]=xm+xl*z; //and put in its symmetric counterpart.
        w[i]=2.0*xl/((1.0-z*z)*pp*pp); //Compute the weight
        w[n-1-i]=w[i]; //and its symmetric counterpart.
    }
}
Doub dimer(Doub g, Doub p, Doub E, Doub m)
{
    return (2./pi)*pow(p,2)/(sqrt(.75*pow(p,2)-m*E)-g);
}


Doub exchange(Doub q, Doub p, Doub E, Doub m)
{
    return (1./(q*p))*log((pow(q,2)+pow(p,2)+q*p-m*E)/(pow(q,2)+pow(p,2)-q*p-m*E));
}

Doub inhomogenous(Doub ro, Doub g, Doub p, Doub m, Doub E)
{
    return (ro/2)*(g+sqrt(.75*pow(p,2)-m*E));
}

Doub dimer2(Doub g, Doub q, Doub E, Doub m)
{
    return (2./pi)*pow(q,2)/(sqrt(.75*pow(q,2)-m*E)-g);
}

Doub exchangeprime(Doub q, Doub p, Doub E, Doub m)
{
    return (2*m)/(pow(pow(q,2)+pow(p,2)-m*E,2)-pow(q,2)*pow(p,2));
}

Doub dimer2prime(Doub g, Doub q, Doub E, Doub m)
{
    return (m/pi)*pow(q,2)/sqrt(.75*pow(q,2)-m*E)*1./pow(sqrt(.75*pow(q,2)-m*E)-g,2);
}

Doub timesgamma0(Doub g, Doub q, Doub E, Doub m)
{
    return (m/(4*pi))*pow(q,2)/(pow((sqrt(.75*pow(q,2)-m*E)-g),2)*sqrt(.75*pow(q,2)-m*E));
}

Doub timesgamma0prime(Doub g, Doub q, Doub E, Doub m)
{
    return (1/(2*pi))*pow(q,2)/(sqrt(.75*pow(q,2)-m*E)-g);
}

int main()
{
    Doub g=45.;
    Doub m=938.;
    Doub q,p;
    Doub E=-8.;
    Doub ro=.01;
    Doub product;
    int N=100;
    mat A(N,N);
    mat B;
    vec gamma1(N);
    vec productprime(N);
    Doub sigma0prime;
    VecDoub_O x(N);
    VecDoub_O w(N);
    ofstream plot0;
    ofstream plot1;
    ofstream plot0prime;
    ofstream plotsigma;
    plot0.open ("gamma0.dat");
    plot1.open ("gamma1.dat");
    plot0prime.open ("gamma0prime.dat");
    plotsigma.open ("sigma0prime.dat");
    gauleg(0.,1000.,x,w);
    for(int i=1;i<x.size();i++)
    {
        q=x[i];
        for (int j=1;j<N;j++)
        {
            p=x[j];
            product=w[j]*dimer(g,p,E,m)*exchange(q,p,E,m);
            A(i,j)=product;
        }
    }
    mat identity (N, N,fill::eye);
    mat LO=identity-A;
    mat LO1=inv(LO);
    B.ones(1, N);
    vec gamma0=LO1*trans(B);
    for (int j=1;j<N;j++)
        gamma1(j)=gamma0(j)*inhomogenous(ro,g,x[j],m,E);
    gamma1=LO1*gamma1;
    for (int i=1;i<N;i++)
    {
        plot0<<x[i]<<"\t"<<gamma0(i)<<"\n";
        plot1<<x[i]<<"\t"<<gamma1(i)<<"\n";
    }
    plot0.close();
    plot1.close();
    for(int i=1;i<x.size();i++)
    {
        p=x[i];
        for (int j=1;j<N;j++)
        {
            q=x[j];
            productprime(i)=w[j]*dimer2(g, q, E, m)*gamma0(j)*exchangeprime(q, p, E, m)+w[j]*exchange(q,p,E,m)*gamma0(j)*dimer2prime(g, q, E, m);
           // inprime(i,j)=productprime;
        }
    }
    vec gamma0prime=LO1*productprime;
    for(int i=1;i<x.size();i++)
    {
        q=x[i];
        sigma0prime=w[i]*timesgamma0(g, q, E, m)*gamma0(i)+w[i]*timesgamma0prime(g, q, E, m)*gamma0prime(i);
    }
    vec normalized=(sqrt(pi/sigma0prime))*gamma0;
    for (int i=1;i<N;i++)
    {
        plotsigma<<x[i]<<"\t"<<normalized(i)<<"\n";
    }
    plotsigma.close();
}
//inprime=dimer2(g, q, E, m)*gamma0(i)*exchangeprime(q, p, E, m)+exchange(q,p,E,m)*gamma0(i)*dimer2prime(g, q, E, m);
/*    for(int i=1;i<x.size();i++)
    {
        q=x[i];
        for (int j=1;j<N;j++)
        {
            p=x[j];
            productprime=w[j]*(dimer2(g, q, E, m)*gamma0(j)*exchangeprime(q, p, E, m)+exchange(q,p,E,m)*gamma0(j)*dimer2prime(g, q, E, m)+exchange(q,p,E,m)*dimer2(g, q, E, m));
            newterm(i,j)=productprime;
        }
    }
    mat LOprime=identity-newterm;
    mat LOprime1=inv(LOprime);
    vec gamma0prime=LOprime1*newterm;
    for (int i=1;i<N;i++)
    {
        plot0prime<<x[i]<<"\t"<<gamma0prime(i)<<"\n";
    }
    plot0prime.close();
}
*/
